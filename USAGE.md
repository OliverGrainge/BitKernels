# BitKernels Usage Guide

This guide shows you how to build, test, and benchmark the BitKernels library.

## Quick Start

### Building

```bash
# Build everything (library, tests, benchmarks)
./build.sh

# Clean build
./build.sh Release clean
```

### Testing

```bash
# Run complete test suite (generates Python reference data + runs C++ tests)
./test.sh
```

The test suite will:
1. Generate test data using Python (bitlinear.py)
2. Build C++ tests if needed
3. Run tests comparing C++ vs Python outputs
4. Report PASS/FAIL for GEMM and GEMV kernels

### Benchmarking

```bash
# Run benchmarks with default dimensions (M=128, K=4096, N=4096)
./bench.sh

# Run with custom dimensions
./bench.sh 256 2048 2048
```

## Directory Structure

```
BitKernels/
├── include/bitkernels/          # Public API headers
│   ├── types.h                  # Common types (PackedWeights)
│   └── bitlinear.h              # BitLinear operations
│
├── src/                         # Implementation
│   ├── common/                  # Common utilities
│   │   ├── types.cpp           # Type implementations
│   │   └── utils.h             # Packing utilities
│   ├── bitlinear/
│   │   ├── dispatch.cpp        # Runtime dispatch
│   │   ├── prepare_weights.cpp # Weight quantization
│   │   └── arm_neon/           # ARM NEON kernels
│   │       ├── gemm.cpp        # Matrix-matrix (M > 1)
│   │       └── gemv.cpp        # Matrix-vector (M = 1)
│
├── python/                      # Python bindings
│   ├── bitkernels/
│   │   ├── __init__.py
│   │   └── _C.cpp              # pybind11 bindings
│   ├── setup.py
│   └── pyproject.toml
│
├── tests/cpp/                   # C++ tests
│   └── test_bitlinear.cpp
│
├── benchmarks/                  # Performance benchmarks
│   └── bench_bitlinear.cpp
│
├── build.sh                     # Build script
├── test.sh                      # Test runner
└── bench.sh                     # Benchmark runner
```

## API Usage

### C++ API

```cpp
#include "bitkernels/bitlinear.h"

// 1. Prepare weights (one-time operation)
bitkernels::PackedWeights weights;
bitkernels::prepare_weights(W_fp32, N, K, weights);

// 2. Forward pass (automatic dispatch based on M)
float* Y = new float[M * N];
bitkernels::bitlinear_forward(X_fp32, M, K, weights, Y);

// Or use explicit kernels:
bitkernels::bitlinear_gemm(X_fp32, M, K, weights, Y);  // Matrix-matrix
bitkernels::bitlinear_gemv(X_fp32, K, weights, Y);     // Matrix-vector (single row)
```

### Python API (Future)

```python
import bitkernels
import numpy as np

# Prepare weights
W = np.random.randn(N, K).astype(np.float32)
packed_weights = bitkernels.prepare_weights(W)

# Forward pass
X = np.random.randn(M, K).astype(np.float32)
Y = bitkernels.bitlinear_forward(X, packed_weights)
```

## Performance

On Apple M3 Max (ARM):
- **GEMM** (M=128, K=2048, N=2048): ~103 GFLOPS, 10.4 ms
- **GEMV** (K=2048, N=2048): ~21 GFLOPS, 0.4 ms

Features:
- 4× weight compression (2-bit ternary encoding)
- Tiled computation for cache efficiency
- NEON SDOT/VMULL vectorization
- OpenMP parallelization

## Test Details

### test_bitlinear

Tests both GEMM and GEMV kernels against Python reference implementation:
- Loads test data generated by `bitlinear.py`
- Compares C++ output vs Python output
- Reports error metrics (max absolute error, mean error, relative error)
- Passes if errors are below threshold (1e-4 absolute or 1e-3 relative)

### bench_bitlinear

Benchmarks both kernels with configurable dimensions:
- Warmup runs to stabilize performance
- Multiple iterations for accurate timing
- Reports GFLOPS and memory bandwidth
- Summary table comparing kernels

## Build Configuration

CMake options:
```bash
cmake -DCMAKE_BUILD_TYPE=Release \     # Release or Debug
      -DBUILD_TESTS=ON \               # Build tests
      -DBUILD_BENCHMARKS=ON \          # Build benchmarks
      -DBUILD_PYTHON=ON \              # Build Python bindings
      ..
```

## Adding New Architecture

To add x86 AVX support:

1. Create `src/bitlinear/x86_avx/gemm.cpp` and `gemv.cpp`
2. Implement `x86_avx::bitlinear_gemm_impl()` and `bitlinear_gemv_impl()`
3. Update `src/bitlinear/dispatch.cpp` to detect and dispatch to x86 kernels
4. Update `CMakeLists.txt` to compile new sources when on x86

## Troubleshooting

### Tests fail with "Cannot open data/*.bin"
Run `python bitlinear.py` first to generate test data.

### Build fails with OpenMP errors
On macOS: `brew install libomp`
On Linux: `sudo apt-get install libomp-dev`

### Python bindings don't build
Install pybind11: `pip install pybind11`
Then rebuild with: `cmake -DBUILD_PYTHON=ON ..`

## Performance Tuning

Key parameters in `src/bitlinear/arm_neon/gemm.cpp`:
```cpp
constexpr size_t M_TILE = 8;   // Process 8 input rows together
constexpr size_t N_TILE = 32;  // Process 32 output channels together
```

Adjust based on your cache sizes for optimal performance.

## Contributing

When contributing:
1. Ensure tests pass: `./test.sh`
2. Ensure benchmarks run: `./bench.sh`
3. Follow existing code style
4. Add tests for new features

